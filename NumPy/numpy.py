# -*- coding: utf-8 -*-
"""NumPy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yI3pllwLablJZWT5JKL8gDG0UyUzHbU_

#Python:- Numpy Arrays
"""

import numpy as np

"""
One way to create a numpy array is from an existing object
such as list

"""

ls=[1,2,3]
type(ls)

# transform this list into an array

np.array(ls)

arr=np.array(ls)
arr

# Transform a nested list into a numpy array
# which is called matrix

ls=[[1,2,3],[4,5,6],[7,8,9]]
ls

mtr=np.array(ls)
mtr
# this is 2D matrix.
# we can check how many dimensions it has, based on the number
# brackets that are shows in the beginning or at the very end
# we have X-axis and Y-axis which makes it 2D matrix.

mtr.shape
#to check built in methods 1st need to run the mtr object

"""**Built in Methods**

"
Numpy. arange is a function that produces an array of
sequential numbers within a given interval.
It differs from Python's builtin range()
function in that it can handle floating-point
numbers as well as arbitrary step sizes.
Also, the output of numpy.
arange is an array of elements instead of a range object.
"""

np.arange(1,10,1)

# start,stop,step-size(by default is 1)
# start from any number and goes all the way upto, but not
# including stop index.
# start is inclusive and the end is exclusive.

" Zeros and Ones"

"Zeros:-\
Return a new array of given shape and type, filled with zeros\
gives 1D array"

np.zeros(5)

# dot after 0 indicating that it's a floating point number.

type(0.)

np.zeros((4,5))

# passing a tuple can create matrix.
# (rows,columns)

"""
Python numpy. ones() function returns a new array of
 given shape and data type, where the element's
 value is set to 1.
"""

np.ones(5)

np.ones((5,5))

"""
Numpy allows you to perform operations that are broadcasted to
every single number on  the array.

Meaning , if i take my ones, and I add four,numpy will add
4 to each ones

this is not possible with normal python list.

for example if we multiply python list with any number
instead of performing operation it will print list number.

[1,1,1]*100 will print each 1 , 100 times

if we try to add [1,1,1]+100 will give an error.
can't concatenate a list to an integer because they are
two different data types

Numpy can do this. can perform any operation. add,multipy,divide

"""

np.ones((5,5)) +4

np.ones(5) *100

np.ones(10)/108

"""
Create linearly spaces arrays that return evenly spaced numbers
over a specified interval,
A little different than arange method.

arange allow you to define the size of the step.
linspace allow you to define the number of steps.
linspace(0,1,20) : 20 evenly spaced numbers from 0 to 1 (inclusive).
arange(0, 10, 2) : however many numbers are needed to
go from 0 to 10 (exclusive)

arange return integers from a start, a stop and then a step size
NP linspace, is an inclusive start, an inclusive stop and then
we get to ask how many numbers we want
"""

np.linspace(0,100,5)

np.arange(0,10,3)

np.linspace(0,10,20)

"""
Identity matrix

NumPy eye() The eye() method creates a
2D array with 1s on the diagonal and 0s elsewhere.
"""

np.eye(5)

"""
Random number Numpy

The numpy. random. rand() function creates an array of
specified shapes fills it with random values and
generates random numbers with Numpy.

What is the difference between np random rand() and
np random randn()?

random. rand() produces random numbers from a
uniform distribution over the interval [0, 1),

while np. random. randn() generates random numbers
from a standard normal distribution.
Standard normal distribution has mean at zero and standard
deviation of 1.
"""

np.random.rand(4)

np.random.rand(4,5)

np.random.randn(5)

# specify mean and sigma

np.random.normal(loc=10,scale=110)

#loc is mean and scale is Standard deviation.

"""
Return random integers from low (inclusive) to high (exclusive).
Return random integers from the “discrete uniform”
distribution of the specified dtype in the “half-open”
interval [low, high). If high is None (the default),
then results are from [0, low).

It will return 1 random number/in range between high and low.
"""

np.random.randint(1,10)

np.random.randint(1,10,20)

# set a seed thats sets the random state that way the
# the random results can be actually reproduced
# will give each time same numbers
# number 42 does not have any particularly meaning
# its just an arbitrary number chosen.
# seed should be in the same cell otherwise it will give
# different numbers
np.random.seed(42)
np.random.randint(1,100,10)

np.random.seed(42)
np.random.rand(4)

np.random.seed(555)
np.random.rand(4)

"""**Array attributed and Methods**"""

arr=np.arange(25)
arr #arange array

ranarr=np.random.randint(0,50,10)
ranarr #random array

arr.shape

"""Reshape

Gives a new shape to an array without changing its data.

reshape() is used to create a new array of the same size
(as the original array) but of different desired dimensions.
resize() can create an array of larger size than the
original array.

.shape gives us shape of the array. but sometimes what if we do
not want 1D array may be we want 2D array.

Somthings we have to be careful is that we can't just choose
any arbitrary values for reshape. if for this example if
reshape(5,3) will give an arrray because array has 25 elements.
it will not fit. because it has space only for 15 elements.

"""

arr.reshape(5,5)

"""
max:-
The max() method returns the largest element of an
array along an axis.

min:-
Return the minimum of an array or minimum along an axis.

argmax:-
Returns the indices of the maximum values along an axis.
Input array. By default, the index is into the flattened
array, otherwise along the specified axis.

argmin:-

numpy. argmin (a, axis=None, out=None)[source] Returns the
 indices of the minimum values along an axis.

"""

ranarr

ranarr.max()

ranarr.min()

#it does not tell index location

ranarr.argmax()

ranarr.argmin()

ranarr.dtype #type of data in random array.

"""#Numpy Index Selection"""

arr=np.arange(0,11)
arr

"""
bracket indexing and selection

Indexing:- Lets imagine we wanted to get 1 single value from
this 1D array. To do that, it works just like a normal
Python list.

"""

arr[3]

# values within range just like Python list
# It will not include last value.


arr[1:4]

arr[0:5]

arr[:5]

arr[5:]

#will not include 1st 5 elements.

"""
Broadcasting:-

NumPy arrays differ from normal python lists because they allow
broadcasting functions and operations across this.


"""

arr

arr+100

arr/2

arr**2

# this is general broadcasting

arr

slice_arr=arr[0:6]
slice_arr

# Broadcast a reassignment to the slice of this array.

slice_arr[:]=99

slice_arr

# slice_arr=arr[0:6] is directly pointing to the original array
# which means when we call original array
# 1st 5 elements are changed.
# So that's sort of broadcasting of reassignment based off a
# Slice like this.

arr

# if we do not want the original array affected
# we need to be explicit when a creating a copy
arr_copy=arr.copy()
print(arr_copy)

print(" ")

arr_copy[:]=1000
print(arr_copy)

print(" ")

print(arr)

"""
Indexing and selection on 2D array
And then conditional selection based off some bullion condition.


"""

arr_2d=np.array([[5,10,15,],[20,25,30],[35,40,45]])
arr_2d

arr_2d.shape

arr_2d[1]

arr_2d[1][1]

arr_2d[1,1]

arr_2d[2,2]

arr_2d

arr_2d[:2] #1st two rows

arr_2d[:2,1:]

"""
Conditional selection:-

It is a fundamental concept that directly translates to Pandas
and it allows us to use comparison operators to acutally grab
elements.

"""

arr=np.arange(1,11)
arr

#bullion comparison
arr>4

bool_arr=arr>4
bool_arr

arr[bool_arr]

# it will only reutnr values where the index locations were true.

arr[arr>4]

# exact same thing in 1 step

"""# Numpy Operations

When we performing operations on NumPy its often on an element
by element basis where the operation is broadcasted across the
array.

When we try to divide by zero or infinity NumPy will actually
not produce a full error. Instead it will just produce a warning
"""

arr=np.arange(10)
arr

arr+100

arr/100

arr**2

(arr+2)/10

arr+arr

1/arr
#warning when we divide by zero.

arr/arr

np.sqrt(arr)

np.log(arr)

np.sin(arr)

arr.sum()

arr.mean()

arr.max()

arr_2d=np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])

print(arr_2d)
print(arr_2d.shape)

arr_2d.sum()

arr_2d.sum(axis=0)

#sum of each column in 1D array

arr_2d.sum(axis=1)

#sum of each row in 1D array